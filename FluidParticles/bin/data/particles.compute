/*

FluidParticles inspired by https://knork.org/doubleRelaxation.html

*/

#version 440

layout (std140, binding = 0) buffer PositionBuffer{
	vec4 positionBuffer[];
};

layout (std140, binding = 1) buffer PositionOutBuffer{
	vec4 positionOutBuffer[];
};

layout (std140, binding = 2) buffer VelocityBuffer{
	vec4 velocityBuffer[];
};

uniform float dt;
//uniform SimulationData simData;
uniform float interactionRadius;
uniform float rho0;
uniform float spring;
uniform float springNear;
uniform vec3 gravity;
uniform int numberOfParticles;
uniform vec3 mDimension;

vec4 calculatePressure(uint index);
mat2x4 applyViscosity(uint index, vec3 velocity);

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;
void main(){
	uint index = gl_GlobalInvocationID.x;
	
	if(index >= numberOfParticles)
		return;
	
	// positionOutBuffer[index] = positionBuffer[index];
	// velocityBuffer[index] = calculatePressure(index);
	vec3 particlePosition = positionBuffer[index].xyz;
	vec3 particleVelocity = velocityBuffer[index].xyz;
	//vec4 particlePressure = calculatePressure(index);
	// vec3 particlePressure = vec3(0,0,0);
	
	// gravity
	particleVelocity += (gravity) * dt;
	// ***g

	// fluid simulation
	mat2x4 fl = applyViscosity(index, particleVelocity);
	particlePosition = fl[0].xyz;
	particleVelocity = fl[1].xyz;
	//particleVelocity += calculatePressure(index).xyz * dt;
	// *** fs

	// static collision
	for (int i = 0; i < 3; ++i)
	{
		if ((particlePosition[i] + particleVelocity[i] * dt > mDimension[i] && particleVelocity[i] > 0.f) || (particlePosition[i] + particleVelocity[i] * dt < 0.f && particleVelocity[i] < 0.f))
		{
			if (particlePosition[i] + particleVelocity[i] * dt < 0.f)
				particlePosition[i] = 0.f;
			else
				particlePosition[i] = mDimension[i];

			particleVelocity[i] *= -.3f;	
		}
	}
	// *** sc

	//particleVelocity -= dt * particleVelocity * 0.1f;//damping
	particlePosition += particleVelocity * dt;

	positionOutBuffer[index] = vec4(particlePosition, fl[0].w);
	velocityBuffer[index] = vec4(particleVelocity, numberOfParticles);
	//velocityBuffer[index] = particlePressure;
}

vec4 calculatePressure(uint index)
{
	//float interactionRadius = 18.f;
	float amplitude = 1.0f;
	vec3 particlePosition = positionBuffer[index].xyz;
	
	vec4 pressureVec = vec4(0.f, 0.f, 0.f, 0.f);
	for (int i = 0; i < numberOfParticles; i++)
	{
		if (index == i)
			continue;

		vec3 dirVec = particlePosition - positionBuffer[i].xyz;
		float dist = length(dirVec);

		//if (dist > interactionRadius * 1.0f || dist < 0.01f)
		if (dist > interactionRadius * 1.0f)
			continue;

		float pressure = 1.f - (dist/interactionRadius);
		//float pressure = amplitude * exp(-dist / interactionRadius);
		
		pressureVec += vec4(pressure * normalize(dirVec), 0.f);
		// pressureVec += vec4(dirVec, 0.f);
		
		pressureVec.w += pressure;
		
		//break;
	}
	
	return pressureVec;
}

mat2x4 applyViscosity(uint index, vec3 velocity)
{
	mat2x4 result;

	vec3 vel = velocity;
	vec3 pos = positionBuffer[index].xyz;
	float alpha = 1.f;
	float beta = 1.f;
	float rho = 0.0f;
	float rhoNear = 0.0f;

	for (int i = 0; i < numberOfParticles; i++)
	{
		if (index == i)
			continue;

		vec3 dirVec = pos - positionBuffer[i].xyz;
		float dist = length(dirVec);
		positionBuffer[i].w = dist;

		//if (dist > interactionRadius * 1.0f || dist < 0.01f)
		if (dist > interactionRadius)
			continue;

		vec3 dirVecN = normalize(dirVec);
		float moveDir = dot(vel - velocityBuffer[i].xyz, dirVecN);
		float distRel = dist / interactionRadius;

		// viscosity
		if (moveDir > 0)
		{
			vec3 impulse = (1.f - distRel) * (alpha * moveDir + beta * moveDir * moveDir) * dirVecN * dt;
			vel -= impulse * 0.5f;//goes back to the caller-particle
			//velocityBuffer[i].xyz += impulse * 0.5f;//changes neighbour velocity directly
		}
		// *** v

		// double realxation
		float distRel2 = (1.f - distRel) * (1.f - distRel);
		rho += distRel2; // density, uses quadratic kernel
		rhoNear += distRel2 * (1.f - distRel);// near density, cubic kernel
		// *** dr
	}
	
	float pressure = (rho - rho0) * spring;
	float pressureNear = rhoNear * springNear;

	vec3 displace = vec3(0.f);
	for (int i = 0; i < numberOfParticles; i++)
	{
		if (index == i)
			continue;

		float dist = positionBuffer[i].w;

		//if (dist > interactionRadius * 1.0f || dist < 0.01f)
		if (dist > interactionRadius)
			continue;

		float distRel = dist / interactionRadius;
		vec3 dirVecN = normalize(pos - positionBuffer[i].xyz);

		float pressureEffect = pressure * (1.f - distRel);
		float pressureNearEffect = pressureNear * (1.f - distRel) * (1.f - distRel);
		float df = (pressureEffect + pressureNearEffect) * dt * dt;
		vec3 d = dirVecN * df;
		//positionOutBuffer[i].xyz += d * 0.5f;
		displace -= d;
	}

	//pos += displace;
	//vel += displace;

	result[0].xyz = pos;
	result[1].xyz = vel;

	//result[0].w = rho;
	result[0].w = positionBuffer[index].w;// length(displace);

	return result;
}
